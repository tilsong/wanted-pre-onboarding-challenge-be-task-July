## (4) 본인이 주력으로 사용하는 언어에서 설계적 결함 한 가지를 작성해주세요.
- java: 설계와 트레이드오프의 결과로 몇몇 결함이나 한계점이 생길 수 있습니다.
  1. Null 참조
     - "Null 참조"라는 개념은 객체 지향 프로그래밍에서 "아무것도 가리키지 않음"을 표현하는 개념입니다.
        자바는 null 참조를 허용하는데, 이는 여러 문제를 야기할 수 있습니다.
     - null이 특정 변수에 할당되었을 때, 이 변수를 사용해서 메소드를 호출하거나 필드에 접근하려고 할 때
       NullPointerException이 발생하게 됩니다. 
     - 이 예외를 방지하기 위해 null 체크로 이런 상황을 방지해야 하는데, 만일 체크가 누락되면 애플리케이션이 예상치 못한 방식으로 종료되거나,
       시스템 안정성이 훼손되는 등의 문제가 발생할 수 있습니다. 디버깅도 어려워집니다.
     - 이렇게 null 참조로 인해 나타나는 버그와 이를 디버깅하는 시간과 비용을 billion dollar mistake라고 부릅니다.

<br>
- 추가로 다른 결함이나 한계점이 있는지 살펴보았습니다.
  1. 타입 소거(Type Erasure)
     - 자바의 제네릭 타입은 컴파일 시점에 타입을 체크하기 위한 메커니즘입니다.
       한편 컴파일 시점 이후 런타임 시에는 타입 정보가 소거됩니다.
     - 이 때문에 문제가 발생할 수 있는데, 제네릭 배열 생성이 불가합니다. 예를 들어 List<Integer>[]라는 제네릭 배열은
       실행 시점에 List<Integer> 정보가 삭제되어 그냥 List[]가 되기 때문입니다.
  2. 기본 타입과 박싱 타입의 불일치 문제
     ```java
        Integer a = 500;
        Integer b = 500;
        System.out.println(a == b); // 결과는 "false"
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b); // 결과는 "true"
     ```
     - 첫 예제는 참조를 반환하므로 false 결과가 나옵니다.
     - 두번째 예제는 자바에서[-128, 127] 범위의 Integer 인스턴스는 캐싱되므로 같은 값을 가진
       'Integer' 인스턴스는 동일한 참조를 가집니다.
     - 이런 불일치 문제를 해결하기 위해 박싱된 타입을 비교할 때는 항상 'equals()' 메소드를 사용해야 합니다.
     


